<%% if (!disable.segment && !sd.THIRD_PARTIES_DISABLED && sd.SEGMENT_WRITE_KEY) { %>
<script type="text/javascript" defer>

!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t,e){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=e};analytics.SNIPPET_VERSION="4.1.0";

const WRITE_KEY = "<%%= sd.SEGMENT_WRITE_KEY %>";
const SEGMENT_MAPPING = 'C0001';
let SEGMENT_DESTINATIONS = [];

fetchDestinations(WRITE_KEY).then(
  destinations => {
    console.log('segment destinations');
    console.log(destinations);

    SEGMENT_DESTINATIONS = destinations;

    waitForOneTrust();

    if (oneTrustReady()) {
      getConsentAndLoadSegment();
    }
  }
)

window.OptanonWrapper = getConsentAndLoadSegment;

function getConsentAndLoadSegment() {
  let oneTrustConsent = '';

  oneTrustConsent = window.OnetrustActiveGroups.split(',');

  console.log('onetrust consent');
  console.log(oneTrustConsent);
  console.log('setting segment destination preferences based on onetrust consent.');

  const destinationPreferences = setSegmentDestinationPref(oneTrustConsent, SEGMENT_DESTINATIONS);

  conditionallyLoadAnalytics({
    writeKey: WRITE_KEY,
    destinations: SEGMENT_DESTINATIONS,
    destinationPreferences
  });
}

function conditionallyLoadAnalytics({
  writeKey,
  destinations,
  destinationPreferences,
  shouldReload = true
}) {
  let isAnythingEnabled = false;

  for (const destination in destinationPreferences) {
    const isEnabled = destinationPreferences[destination];
    if (isEnabled) {
      isAnythingEnabled = true;
    }
  }

  if (isAnythingEnabled) {
    console.log('loading segment analytics js');
    window.analytics.load(writeKey, { integrations: destinationPreferences });
  }
}

function setSegmentDestinationPref(oneTrustConsent, destinations) {
  const segmentToOneTrust= {
    'SMS & Push Notifications': 'C0001',
    'Analytics': 'C0002',
    'Advertising': 'C0004'
  }

  const destinationPreferences = destinations
    .map(function(dest) {
      console.log(dest);
      if ((dest.category in segmentToOneTrust) && oneTrustConsent.includes(segmentToOneTrust[dest.category])) {
        console.log('is allowed by onetrust');
        return { [dest.id]: true };
      } else {
        return { [dest.id]: false };
      }
    })
    .reduce(
      (acc, val) => {
        return {
          ...val,
          ...acc
        };
      },
      { "Segment.io": oneTrustConsent.some(d => d === SEGMENT_MAPPING) }
    );

  console.log('desination pref:');
  console.log(destinationPreferences);

  return destinationPreferences;
}

function waitForOneTrust() {
  let attempts = 0;
  const maxAttempts = 100;

  if (!oneTrustReady()) {
    console.log('onetrust is NOT ready');

    const interval = setInterval(() => {
      console.log('waiting for onetrust');
      if (oneTrustReady || attempts > maxAttempts) clearInterval(interval);
      attempts++;
    }, 10);
  }
}

function oneTrustReady() {
    if ((typeof window.OnetrustActiveGroups === 'string') && (window.OnetrustActiveGroups.split(',').includes('C0001'))) {
      return true;
    }
    return false;
}

async function fetchDestinations(writeKey) {
  let destinations = await fetchDestinationForWriteKey(writeKey);

  destinations = [
    ...destinations
      .reduce((map, item) => {
        if (item.id === "Repeater") return map; // remove Segment Repeater destinations
        map.has(item["id"]) || map.set(item["id"], item);
        return map;
      }, new Map()) // return object
      .values()
  ];

  return destinations;
}

async function fetchDestinationForWriteKey(writeKey) {
  const res = await window.fetch(
    `https://cdn.segment.com/v1/projects/${writeKey}/integrations`
  );

  if (!res.ok) {
    throw new Error(
      `Failed to fetch Segment destinations: HTTP ${
        res.status
      } ${res.statusText}`
    );
  }

  const destinations = await res.json();

  // Rename creationName to id to abstract the weird data model
  for (const destination of destinations) {
    destination.id = destination.creationName;
    delete destination.creationName;
  }

  return destinations;
}

}}();
</script>

<%% } %>
