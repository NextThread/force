<%% if (!disable.segment && !sd.THIRD_PARTIES_DISABLED && sd.SEGMENT_WRITE_KEY) { %>
<script type="text/javascript" defer>

!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t,e){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=e};analytics.SNIPPET_VERSION="4.1.0";

// adaptation of:
//   https://gist.github.com/sperand-io/4725e248a35d5005d68d810d8a8f7b29
//   https://github.com/littledata/shopify-tracker/blob/ec4fac54cd56344980aa481800ee8dba550ea97d/src/customerPrivacyAPI/oneTrust.ts#L31

const SEGMENT_WRITE_KEY = "<%%= sd.SEGMENT_WRITE_KEY %>";
const SEGMENT_MAPPING = 'C0001'; // Segment itself assigned OneTrust Strictly Necessary category.
let SEGMENT_DESTINATIONS = [];

fetchDestinations(SEGMENT_WRITE_KEY).then(
  destinations => {
    SEGMENT_DESTINATIONS = destinations;

    waitForOneTrust();

    if (oneTrustReady()) {
      getConsentAndLoadSegment();
    }
  }
)

// OneTrust calls OptanonWrapper when there's a consent change.
window.OptanonWrapper = getConsentAndLoadSegment;

function waitForOneTrust() {
  let attempts = 0;
  const maxAttempts = 100;

  // wait 1sec at most.
  if (!oneTrustReady()) {
    const interval = setInterval(() => {
      if (oneTrustReady() || attempts > maxAttempts) clearInterval(interval);
      attempts++;
    }, 10);
  }
}

function oneTrustReady() {
    // OneTrust is ready if OnetrustActiveGroups contains at least Strictly Necessary group.
    if ((typeof window.OnetrustActiveGroups === 'string') && (window.OnetrustActiveGroups.split(',').includes('C0001'))) {
      return true;
    }
    return false;
}

async function fetchDestinations(writeKey) {
  let destinations = await fetchDestinationForWriteKey(writeKey);

  destinations = [
    ...destinations
      .reduce((map, item) => {
        if (item.id === "Repeater") return map; // remove Segment Repeater destinations
        map.has(item["id"]) || map.set(item["id"], item);
        return map;
      }, new Map()) // return object
      .values()
  ];

  return destinations;
}

function getConsentAndLoadSegment() {
  let oneTrustConsent = '';

  // OneTrust stores consent in OnetrustActiveGroups.
  oneTrustConsent = window.OnetrustActiveGroups.split(',');

  const destinationPreferences = setSegmentDestinationPref(oneTrustConsent, SEGMENT_DESTINATIONS);

  conditionallyLoadAnalytics({
    writeKey: SEGMENT_WRITE_KEY,
    destinations: SEGMENT_DESTINATIONS,
    destinationPreferences
  });
}

function setSegmentDestinationPref(oneTrustConsent, destinations) {
  // maps Segment destination's category to OneTrust cookie category.
  const segmentToOneTrust= {
    'SMS & Push Notifications': 'C0001', // OneTrust Strictly Necessary
    'Analytics': 'C0002', // OneTrust Performance
    'Advertising': 'C0004' // OneTrust Targeting
  }

  const destinationPreferences = destinations
    .map(function(dest) {
      if ((dest.category in segmentToOneTrust) && oneTrustConsent.includes(segmentToOneTrust[dest.category])) {
        return { [dest.id]: true };
      } else {
        // if we don't have a mapping for the Segment category, or we do but there's no OneTrust consent.
        return { [dest.id]: false };
      }
    })
    .reduce(
      (acc, val) => {
        return {
          ...val,
          ...acc
        };
      },
      { "Segment.io": oneTrustConsent.some(d => d === SEGMENT_MAPPING) }
    );

  return destinationPreferences;
}

function conditionallyLoadAnalytics({
  writeKey,
  destinations,
  destinationPreferences,
}) {
  let isAnythingEnabled = false;

  for (const destination in destinationPreferences) {
    const isEnabled = destinationPreferences[destination];
    if (isEnabled) {
      isAnythingEnabled = true;
    }
  }

  if (isAnythingEnabled) {
    window.analytics.load(writeKey, { integrations: destinationPreferences });
  }

  // if everything is disabled, don't load segment.
}

async function fetchDestinationForWriteKey(writeKey) {
  const res = await window.fetch(
    `https://cdn.segment.com/v1/projects/${writeKey}/integrations`
  );

  if (!res.ok) {
    throw new Error(
      `Failed to fetch Segment destinations: HTTP ${
        res.status
      } ${res.statusText}`
    );
  }

  const destinations = await res.json();

  // Rename creationName to id to abstract the weird data model
  for (const destination of destinations) {
    destination.id = destination.creationName;
    delete destination.creationName;
  }

  return destinations;
}

}}();
</script>

<%% } %>
