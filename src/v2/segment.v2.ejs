<%% if (!disable.segment && !sd.THIRD_PARTIES_DISABLED && sd.SEGMENT_WRITE_KEY) { %>
<script type="text/javascript" defer>

!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t,e){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=e};analytics.SNIPPET_VERSION="4.1.0";

/*
Adapted from:
https://gist.github.com/sperand-io/4725e248a35d5005d68d810d8a8f7b29
*/

const OPT_IN = true;
const YOUR_DOMAIN = "domain.com";
const WEBSITE_WRITE_KEY = "<%%= sd.SEGMENT_WRITE_KEY %>";
const SEGMENT_MAPPING = 1;
const OTHER_WRITE_KEYS = [];

fetchDestinations([WEBSITE_WRITE_KEY, ...OTHER_WRITE_KEYS]).then(
  destinations => {
    consentDecision = [3]

    const destinationPreferences = destinations
      .map(function(dest) {
        if (consentDecision.includes(3)) return { [dest.id]: true };
        if (consentDecision.includes(2)) return { [dest.id]: dest.category === "Advertising" ? false : true };
        if (consentDecision.includes(1)) return { [dest.id]: false };
        if (consentDecision.includes(0)) return { [dest.id]: !OPT_IN };
      })
      .reduce(
        (acc, val) => {
          return {
            ...val,
            ...acc
          };
        },
        { "Segment.io": consentDecision.some(d => d === SEGMENT_MAPPING) }
      );

    conditionallyLoadAnalytics({
      writeKey: WEBSITE_WRITE_KEY,
      destinations,
      destinationPreferences,
      isConsentRequired: OPT_IN
    });
  }
);

window.top.postMessage(JSON.stringify({
  PrivacyManagerAPI: { 
    action: "getConsent",
    timestamp: new Date().getTime(),
    self: YOUR_DOMAIN
  } 
}), "*");

window.addEventListener("message", function reload(e) {
  let data = e.data;
  if (typeof data === "string") {
    try {
      data = JSON.parse(data);
    } catch (e) { /* weird message, bail */}
  }
  if (
    data &&
    data.PrivacyManagerAPI &&
    data.PrivacyManagerAPI.consent === "denied"
  ) {
    return window.location.reload();
  }
},  false);  

function conditionallyLoadAnalytics({
  writeKey,
  destinations,
  destinationPreferences,
  isConsentRequired,
  shouldReload = true
}) {
  let isAnythingEnabled = false;

  if (!destinationPreferences) {
    if (isConsentRequired) {
      return;
    }

    if (!window.analytics.initialized) {
      window.analytics.load(writeKey);
    }
    return;
  }

  for (const destination in destinationPreferences) {
    const isEnabled = destinationPreferences[destination];
    if (isEnabled) {
      isAnythingEnabled = true;
    }
  }

  if (window.analytics.initialized) {
    if (shouldReload) {
      window.location.reload();
    }
    return;
  }

  if (isAnythingEnabled) {
    window.analytics.load(writeKey, { integrations: destinationPreferences });
  }
}

async function fetchDestinationForWriteKey(writeKey) {
  const res = await window.fetch(
    `https://cdn.segment.com/v1/projects/${writeKey}/integrations`
  );

  if (!res.ok) {
    throw new Error(
      `Failed to fetch integrations for write key ${writeKey}: HTTP ${
        res.status
      } ${res.statusText}`
    );
  }

  const destinations = await res.json();

  for (const destination of destinations) {
    destination.id = destination.creationName;
    delete destination.creationName;
  }

  return destinations;
}

async function fetchDestinations(...writeKeys) {
  const destinationsRequests = [];
  for (const writeKey of writeKeys) {
    destinationsRequests.push(fetchDestinationForWriteKey(writeKey));
  }

  let destinations = await Promise.all(destinationsRequests);

  destinations = [
    ...destinations
      .reduce((a, b) => a.concat(b), [])
      .reduce((map, item) => {
        if (item.id === "Repeater") return map;
        map.has(item["id"]) || map.set(item["id"], item);
        return map;
      }, new Map())
      .values()
  ];

  return destinations;
}

}}();
</script>

<%% } %>
